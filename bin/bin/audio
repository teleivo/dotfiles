#!/bin/bash

# Unified audio profile management script
# Usage: audio [music|call|info|help]

# Source common audio utilities
source "$(dirname "$0")/audio-utils"

# Configuration
MIN_OUTPUT_VOLUME=20
MIC_VOLUME=100
CALL_PROFILE="output:analog-stereo+input:mono-fallback"
MUSIC_PROFILE="output:analog-stereo"

# Set output volume with minimum threshold
ensure_output_volume() {
    pactl set-sink-mute @DEFAULT_SINK@ 0
    local current_vol
    current_vol=$(pactl get-sink-volume @DEFAULT_SINK@ | grep -oP '\d+%' | head -1 | tr -d '%')
    if [[ "$current_vol" -lt "$MIN_OUTPUT_VOLUME" ]]; then
        pactl set-sink-volume @DEFAULT_SINK@ "${MIN_OUTPUT_VOLUME}%"
    fi
}

# Show current audio information
show_audio_info() {
    echo "=== Audio System Status ==="

    # Current default devices
    local default_sink
    local default_source
    default_sink=$(pactl get-default-sink)
    default_source=$(pactl get-default-source)
    echo "Default Sink: $default_sink"
    echo "Default Source: $default_source"

    # Headset status
    if is_headset_active; then
        local card_id
        local current_profile
        card_id=$(get_headset_card_id)
        current_profile=$(pactl list cards | grep -A 50 "Card #$card_id" | grep "Active Profile:" | cut -d: -f2- | xargs)
        echo "Headset: Active (Card $card_id)"
        echo "Profile: $current_profile"

        # Determine mode based on profile
        if [[ "$current_profile" == *"input"* ]]; then
            echo "Mode: Call (mic enabled)"
        else
            echo "Mode: Music (mic disabled)"
        fi
    else
        echo "Headset: Using built-in audio"
        echo "Mode: Built-in"
    fi

    # Volume levels
    local sink_vol
    sink_vol=$(pactl get-sink-volume @DEFAULT_SINK@ | grep -oP '\d+%' | head -1)
    local sink_muted
    sink_muted=$(pactl get-sink-mute @DEFAULT_SINK@ | awk '{print $2}')
    local source_vol
    source_vol=$(pactl get-source-volume @DEFAULT_SOURCE@ | grep -oP '\d+%' | head -1)
    local source_muted
    source_muted=$(pactl get-source-mute @DEFAULT_SOURCE@ | awk '{print $2}')

    echo "Output: $sink_vol (muted: $sink_muted)"
    echo "Input: $source_vol (muted: $source_muted)"

    # Priority information
    echo ""
    echo "=== Device Priorities ==="
    pactl list sinks | awk '/node\.name/ { name = $3; gsub(/"/, "", name) } /priority\.driver/ { gsub(/"/, "", $3); print name ": " $3 }'
}

# Profile switching
set_profile() {
    local mode="$1"
    local card_id
    card_id=$(get_headset_card_id)

    case "$mode" in
        call)
            if [[ -n "$card_id" ]]; then
                pactl set-card-profile "$card_id" "$CALL_PROFILE"
            fi
            pactl set-source-volume @DEFAULT_SOURCE@ "${MIC_VOLUME}%"
            pactl set-source-mute @DEFAULT_SOURCE@ 0
            ensure_output_volume
            dunstify "Audio Profile" "Call mode - Mic: ${MIC_VOLUME}%, Output: unmuted" --icon=audio-headphones
            ;;
        music)
            if [[ -n "$card_id" ]]; then
                pactl set-card-profile "$card_id" "$MUSIC_PROFILE"
            fi
            pactl set-source-mute @DEFAULT_SOURCE@ 1
            ensure_output_volume
            dunstify "Audio Profile" "Music mode - Mic: muted, Output: unmuted" --icon=audio-headphones
            ;;
        info)
            show_audio_info
            ;;
        test)
            # Handle test subcommands
            local test_mode="$2"
            case "$test_mode" in
                out)
                    test_audio_output
                    ;;
                loopback)
                    test_audio_loopback
                    ;;
                "")
                    echo "Usage: $0 test [out|loopback]"
                    echo "  out      - Test audio output using speaker-test"
                    echo "  loopback - Test microphone with real-time monitoring"
                    exit 1
                    ;;
                *)
                    echo "Unknown test mode: $test_mode"
                    echo "Usage: $0 test [out|loopback]"
                    exit 1
                    ;;
            esac
            ;;
        help|--help|-h)
            cat << EOF
Audio Profile Management

Usage: $0 [MODE]

MODES:
    music      Switch to music mode (output-only, mic muted)
    call       Switch to call mode (duplex, mic active at 100%)
    info       Show current audio system status
    test       Run audio tests (out, loopback)
    help       Show this help message

EXAMPLES:
    $0 music       # Switch to music mode
    $0 call        # Switch to call mode
    $0 info        # Show current status
    $0 test out    # Test audio output
    $0 test loopback # Test microphone with real-time monitoring

The script automatically detects headsets and applies appropriate profiles.
Built-in audio is used when no supported headset is connected.
EOF
            ;;
        "")
            echo "Usage: $0 [music|call|info|test|help]"
            echo "Run '$0 help' for detailed usage information."
            exit 1
            ;;
        *)
            echo "Unknown mode: $mode"
            echo "Usage: $0 [music|call|info|test|help]"
            exit 1
            ;;
    esac
}

# Test audio output using speaker-test
test_audio_output() {
    echo "=== Audio Output Test ==="
    local default_sink
    default_sink=$(pactl get-default-sink)
    echo "Testing output device: $default_sink"
    echo ""
    echo "You should hear test tones on left and right channels."
    echo "Press Ctrl+C to stop the test."
    echo ""

    # Ensure output is unmuted and at reasonable volume
    ensure_output_volume

    # Run speaker-test with wav files, stereo, one loop
    echo "Starting speaker test..."
    speaker-test -t wav -c 2 -l 1

    echo ""
    echo "Audio output test completed."
}

# Test microphone with real-time loopback monitoring
test_audio_loopback() {
    echo "=== Audio Loopback Test ==="
    local default_source
    local default_sink
    default_source=$(pactl get-default-source)
    default_sink=$(pactl get-default-sink)

    echo "Microphone: $default_source"
    echo "Output: $default_sink"
    echo ""
    echo "This will route your microphone directly to your speakers/headphones"
    echo "so you can hear exactly what others hear during calls."
    echo ""
    echo "WARNING: Use headphones to prevent feedback loops!"
    echo "Press Ctrl+C to stop the test."
    echo ""
    read -r -p "Press Enter to start loopback test, or Ctrl+C to cancel..."

    # Clean up any existing loopback modules first
    cleanup_loopback_modules() {
        local existing_modules
        existing_modules=$(pactl list modules short | grep "module-loopback" | cut -f1)
        for module_id in $existing_modules; do
            pactl unload-module "$module_id" 2>/dev/null || true
        done
    }

    # Set up trap for cleanup on exit/interrupt
    cleanup_and_exit() {
        echo ""
        echo "Cleaning up loopback..."
        if [[ -n "${loopback_id:-}" ]]; then
            pactl unload-module "$loopback_id" 2>/dev/null || true
        fi
        echo "Loopback test stopped."
        exit 0
    }
    trap cleanup_and_exit EXIT INT TERM

    # Clean up any leftover modules
    cleanup_loopback_modules

    # Create a loopback module to route enhanced mic to speakers (same as calls)
    echo "Starting loopback (speak into microphone)..."

    # Check if enhanced source is working, fallback to raw microphone if needed
    local source_to_use="$default_source"
    if [[ "$default_source" == "avantree_echo_cancel_source" ]]; then
        # Try to use enhanced source, but fallback to raw if it's not working
        local raw_source
        raw_source=$(pactl list sources short | grep "alsa_input.*Avantree.*mono-fallback" | cut -f2)
        if [[ -n "$raw_source" ]]; then
            echo "Note: Using raw microphone as WebRTC processing needs manual setup"
            echo "This shows your voice before noise suppression/AGC processing"
            source_to_use="$raw_source"
        fi
    fi

    echo "Using source: $source_to_use"
    local loopback_id
    loopback_id=$(pactl load-module module-loopback source="$source_to_use" sink="$default_sink" latency_msec=250)

    if [[ -n "$loopback_id" ]]; then
        echo "Loopback active (ID: $loopback_id). Speak into your microphone."
        echo "Press Enter to stop..."
        read -r

        # Manual cleanup (trap will also handle it)
        pactl unload-module "$loopback_id" 2>/dev/null || true
        echo "Loopback test stopped."
        trap - EXIT INT TERM  # Remove trap since we're exiting normally
    else
        echo "Failed to create loopback. Check your audio devices."
        exit 1
    fi
}

set_profile "$1" "$2"
